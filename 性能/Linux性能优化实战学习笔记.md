# Linux性能优化实战学习笔记

## [02 | 基础篇：到底应该怎么理解“平均负载”？](https://time.geekbang.org/column/article/69618)

### 平均负载

- 是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，也就是**平均活跃进程数**，它和 CPU 使用率并没有直接关系。

### 平均负载为多少时合理
- 首先你要知道系统有几个 CPU

```cmd
$ grep 'model name' /proc/cpuinfo | wc -l
```

- 当平均负载比 CPU 个数还大的时候，系统已经出现了过载

### uptime

```cmd
02:34:03              //当前时间
up 2 days, 20:14      //系统运行时间
1 user                //正在登录用户数
```

- 最后三个数，依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）

### 小白三板斧

#### 1. uptime 查看平均负载的变化情况

```cmd
# -d 参数表示高亮显示变化的区域
$ watch -d uptime
...,  load average: 1.00, 0.75, 0.39
```

#### 2. mpstat 查看 CPU 使用率的变化情况

```cmd
# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
$ mpstat -P ALL 5
```

#### 3. pidstat 查找罪魁祸首

```cmd
# 间隔5秒后输出一组数据
$ pidstat -u 5 1
```

### 小结

- 平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。
 
 - 平均负载高有可能是 CPU 密集型进程导致的；
 - 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；
 - 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。

## [03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）](https://time.geekbang.org/column/article/69859)

- 过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成了系统性能大幅下降的一个元凶。

- CPU 寄存器和程序计数器（Program Counter，PC）也被叫做 CPU 上下文

- 根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景
  - 进程上下文切换
  - 线程上下文切换
  - 中断上下文切换

### 线程与进程最大的区别

- **线程是调度的基本单位，而进程则是资源拥有的基本单位**。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。
  
  - 当进程只有一个线程时，可以认为进程就等于线程。
  - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
  - 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

### 中断上下文切换

- 为了快速响应硬件的事件，**中断处理会打断进程的正常调度和执行**，转而调用中断处理程序，响应设备事件。

- 跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

- 对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。

## [04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）](https://time.geekbang.org/column/article/70077)

### vmstat 查询系统总体的上下文切换情况

- vmstat 是一个常用的系统性能分析工具，主要用来分析
  - 系统的内存使用情况
  - CPU 上下文切换和中断的次数

```cmd
# 每隔5秒输出1组数据
$ vmstat 5

# 每隔1秒输出2组数据
$ vmstat 1 2
```

需要特别关注的四列内容：

- cs（context switch）是每秒上下文切换的次数。
- in（interrupt）则是每秒中断的次数。
- r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
- b（Blocked）则是处于不可中断睡眠状态的进程数。

### pidstat -w 查看每个进程的详细情况

```cmd
# 每隔5秒输出1组数据
$ pidstat -w 5
```

重点关注两列

- cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数
- nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数

> - **自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换**。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

> - **非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换**。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。


```cmd
# -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标
$ pidstat -w -u 1
```

```cmd
# -wt 参数表示输出线程的上下文切换指标
$ pidstat -wt 1
```

### 观察中断的变化情况

```cmd
# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts
```

- **重调度中断**（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为**处理器间中断**（Inter-Processor Interrupts，IPI）。

### 每秒上下文切换多少次才算正常呢？

- **这个数值其实取决于系统本身的 CPU 性能。**如果系统的上下文切换次数比较稳定，那么从**数百**到**一万以内**，都应该算是正常的。

- 但当上下文切换次数**超过一万次**，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。

- 根据上下文切换的类型，分析原因：
 - 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
 - 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
 - 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。

### 小结
- 可以借助 vmstat 、 pidstat 和 /proc/interrupts 等工具来排查性能问题。

## [05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？](https://time.geekbang.org/column/article/70476)

- **性能分析工具给出的都是间隔一段时间的平均 CPU 使用率，所以要注意间隔时间的设置**，特别是用多个工具对比分析时，你一定要保证它们用的是相同的间隔时间。

### 查看 CPU 使用率

- top 显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况。
- ps 则只显示了每个进程的资源使用情况。

###  CPU 使用率相关的重要指标

- user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。
- nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。
- system（通常缩写为 sys），代表内核态 CPU 时间。
- idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
- iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
- irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
- softirq（通常缩写为 si），代表处理软中断的 CPU 时间。
- steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
- guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。
- guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。

### CPU 使用率过高怎么办？

- GDB（The GNU Project Debugger）， 功能强大的程序调试利器。
  - GDB 并不适合在性能分析的早期应用。
  - GDB 只适合用在性能分析的后期，当你找到了出问题的大致函数后，线下再借助它来进一步调试函数内部的问题。

#### perf 适合在第一时间分析进程的 CPU 问题

- perf 是 Linux 2.6.31 以后内置的性能分析工具。
- 它以性能事件采样为基础
  - 不仅可以分析系统的各种事件和内核性能
  - 还可以用来分析指定应用程序的性能问题

##### 两种最常见方法

```cmd
$ perf top
```

输出结果中，第一行包含三个数据，分别是

- 采样数（Samples）
- 事件类型（event）
- 事件总数量（Event count）

**采样数需要我们特别注意**。如果采样数过少（比如只有十几个），那下面的排序和百分比就没什么实际参考价值了。

再往下看是一个表格式样的数据，每一行包含四列，分别是：

- 第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。
- 第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。
- 第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。
- 最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。

```cmd
perf record 和 perf report
```

perf top 虽然实时展示了系统的性能信息，但它的缺点是并不保存数据，也就无法用于离线或者后续的分析。而 perf record 则提供了保存数据的功能，保存后的数据，需要你用 perf report 解析展示。

```cmd
# 按Ctrl+C终止采样
$ perf record

# 展示类似于perf top的报告
$ perf report
```

在实际使用中，我们还经常为 perf top 和 perf record 加上 -g 参数，开启调用关系的采样，方便我们根据调用链来分析性能问题。


