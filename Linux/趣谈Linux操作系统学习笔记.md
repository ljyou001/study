# [趣谈Linux操作系统](https://time.geekbang.org/column/intro/164)学习笔记

## [02 | 学习路径：爬过这六个陡坡，你就能对Linux了如指掌](https://time.geekbang.org/column/article/87628)

要爬的坡有六个，分别是：

- 熟练使用 Linux 命令行
- 使用 Linux 进行程序设计
- 了解 Linux 内核机制
- 阅读 Linux 内核代码
- 实验定制 Linux 组件
- 最后落到生产实践上。

书单

- 《鸟哥的 Linux 私房菜》想全面学习 Linux 命令
- 《Linux 系统管理技术手册》再深入一点
- 《UNIX 环境高级编程》进一步学习 Linux 程序设计，这本书有代码，有介绍，有原理，非常实用
- 《深入理解 LINUX 内核》。这本书言简意赅地讲述了主要的内核机制。看完这本书，你会对 Linux 内核有总体的了解。不过这本书的内核版本有点老，不过对于了解原理来讲，没有任何问题。
- 《LINUX 内核源代码情景分析》。这本书最大的优点是结合场景进行分析，看得见、摸得着，非常直观，唯一的缺点还是内核版本比较老。

原文最后有形象的插图

## [03 | 你可以把Linux内核当成一家软件外包公司的老板](https://time.geekbang.org/column/article/88060)

QQ 的二进制文件是静态的，称为**程序**（Program），而运行起来的 QQ，是不断进行的，称为**进程**（Process）。

## [04 | 快速上手几个Linux命令：每家公司都有自己的黑话](https://time.geekbang.org/column/article/88761)

Linux 里是“命令行 + 文件”模式

- CentOS 使用 rpm
- Ubuntu 使用 deb

CentOS 下面使用rpm -i jdk-XXX_linux-x64_bin.rpm进行安装，Ubuntu 下面使用dpkg -i jdk-XXX_linux-x64_bin.deb。**其中 -i 就是 install 的意思**。

**rpm -qa** 和 **dpkg -l** 就可以查看安装的软件列表，-q 就是 query，a 就是 all，-l 的意思就是 list。

删除，可以用**rpm -e** 和 **dpkg -r**。-e 就是 erase，-r 就是 remove

### Linux 允许我们配置从哪里下载这些软件的

- 对于 CentOS 来讲，配置文件在 **/etc/yum.repos.d/CentOS-Base.repo** 里
- 对于 Ubuntu 来讲，配置文件在 **/etc/apt/sources.list** 里

### 文件目录规则
- 主执行文件会放在 /usr/bin 或者 /usr/sbin 下面
- 其他的库文件会放在 /var 下面
- 配置文件会放在 /etc 下面

在当前用户的默认工作目录，例如 /root 或者 /home/cliu8 下面，有一个.bashrc 文件。
每次登录的时候，这个文件都会运行，因而把它放在这里。这样登录进来就会自动执行。
当然也可以通过 source .bashrc 手动执行。

- **.bash_profile** 是系统配置信息存储文件，写在里面的系统变量是所有用户共用的，
- **.bashrc** 是个人的配置信息存储文件，只是单用户有效。也就是说，配置了.bashrc后切换用户可能需要重新配置系统变量。

### nohup 命令
- 这个命令的意思是 no hang up（不挂起），也就是说，当前交互命令行退出的时候，程序还要在。
- 当然这个时候，程序不能霸占交互命令行，而是应该在后台运行。最后加一个 **&**，就表示后台运行。

```cmd
$ nohup command >out.file 2>&1 &
```

这里面，“1”表示文件描述符 1，表示标准输出，“2”表示文件描述符 2，意思是标准错误输出，“2>&1”表示标准输出和错误输出合并了。合并到哪里去呢？到 out.file 里。

那这个进程如何关闭呢？我们假设启动的程序包含某个**关键字**，那就可以使用下面的命令。

```cmd
$ ps -ef |grep 关键字 |awk '{print $2}'|xargs kill -9
```

**awk** 工具可以很灵活地对文本进行处理，这里的 awk '{print $2}'是指第二列的内容，是运行的程序 ID。我们可以通过 **xargs** 传递给 kill -9，也就是发给这个运行的程序一个信号，让它关闭。如果你已经知道运行的程序 ID，可以直接使用 kill 关闭运行的程序。

## [05 | 学会几个系统调用：咱们公司能接哪些类型的项目？](https://time.geekbang.org/column/article/89251)

### 进程管理
创建进程的系统调用叫 **fork**

#### 进程内存空间
- 放程序代码的这部分，我们称为**代码段**（Code Segment）
- 放进程运行中产生数据的这部分，我们称为**数据段**（Data Segment）
    - 其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也有动态分配的，会较长时间保存，指明才销毁的，这部分称为**堆**（Heap）。

在堆里面分配内存的系统调用，**brk** 和 **mmap**

- 当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。
- 当分配的内存数量比较大的时候，使用 mmap，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

> 具体是用brk(sbrk)还是mmap，还得看malloc的实现，不同实现的处理方式可能不一样，比如tcmalloc总是优先使用sbrk的，sbrk失败才会用mmap，而在64位debug模式下，会优先使用mmap
> — 卡麦哈麦哈

### 文件管理
Linux 里有一个特点，那就是**一切皆文件**
详见原文描述

每个文件，Linux 都会分配一个**文件描述符**（File Descriptor），这是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。

### 进程间通信
- 发个消息，不需要一段很长的数据，这种方式称为**消息队列**（Message Queue）
    - **msgget** 创建一个新的队列
    - **msgsnd** 将消息发送到消息队列
    - **msgrcv** 从队列中取消息

- 需要交互的信息比较大的时候，可以使用**共享内存**的方式
    - 通过 **shmget** 创建一个共享内存块，
    - 通过 **shmat** 将共享内存映射到自己的内存空间，然后就可以读写了
    - 排他地访问，通过信号量的机制 **Semaphore**

### Glibc
Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。**Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。**

书单
《Operating System Three Easy Picies》一本国外的教材，貌似没有中文版的，但里面的内容讲的相当通俗易懂，推荐给大家作为理论层面的补充

## [06 | x86架构：有了开放的架构，才能打造开放的营商环境](https://time.geekbang.org/column/article/89417)

总线上主要有两类数据

- 一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫**地址总线**（Address Bus）；
- 另一类是真正的数据，这类总线叫**数据总线**（Data Bus）。

## [12 | 进程数据结构（上）：项目多了就需要项目管理系统](https://time.geekbang.org/column/article/91550)

